AES
DES


Je vois exactement o√π tu veux en venir, et je trouve ton approche **tr√®s bien structur√©e et √©volutive**. **Tu veux cr√©er un v√©ritable "Rule Processing System"**, un **syst√®me de transformation avanc√©** bas√© sur des **r√®gles pr√©d√©finies et activables √† la demande**.  

Tu veux :  
1. **Un ensemble de fonctions de transformation** (capitalisation, duplication, suppression, insertion, etc.).  
2. **Un syst√®me de gestion des r√®gles (Rule Processing System)** qui permet d'appeler ces transformations dynamiquement.  
3. **Une mani√®re d‚Äôex√©cuter ces r√®gles sur une wordlist** et de g√©n√©rer **une wordlist enrichie**.  

üëâ **C‚Äôest une tr√®s bonne id√©e**, et √ßa nous rapproche encore plus de la logique utilis√©e par **Hashcat et John the Ripper**, deux outils de r√©f√©rence pour le cracking de mots de passe.  

---

## **Plan d‚Äôaction structur√©**
Nous allons organiser **`RuleApplyer.py`** en plusieurs parties :
1. **D√©finition des fonctions de transformation**  
   - Bas√©es sur tes cat√©gories (capitalisation, suppression, duplication, etc.).
2. **Cr√©ation d‚Äôun Rule Processing System**  
   - Un dictionnaire pour mapper les **codes de r√®gles** vers les **fonctions associ√©es**.  
   - Un deuxi√®me dictionnaire pour g√©rer **le nombre d‚Äôarguments** requis par chaque r√®gle.  
3. **Lecture d‚Äôune wordlist existante et application dynamique des r√®gles**  
   - L'utilisateur choisit les r√®gles √† appliquer.  
   - Le syst√®me applique automatiquement les transformations sur chaque mot.  
   - Les nouveaux mots sont enregistr√©s dans un fichier de sortie.  

---

# **1. Impl√©mentation des fonctions de transformation**
On commence par cr√©er les **fonctions principales** pour appliquer les r√®gles :

```python
import string

# === STRING TRANSFORMATIONS ===

# Capitalisation
def lowerString(curString):  
    return curString.lower()

def upperString(curString):  
    return curString.upper()

def capitalizeString(curString):  
    return curString.capitalize()

def invertCapitalize(curString):  
    return curString[0].lower() + curString[1:].upper() if len(curString) > 1 else curString.lower()

def toggleString(curString):  
    return curString.swapcase()

# Supprimer caract√®res
def truncateLeft(curString):  
    return curString[1:] if len(curString) > 1 else ""

def truncateRight(curString):  
    return curString[:-1] if len(curString) > 1 else ""

# R√©p√©tition
def duplicateString(curString):  
    return curString * 2

def duplicateStringNtimes(curString, n):  
    return curString * n

def duplicateFirst(curString, n):  
    return curString[0] * n + curString

def duplicateLast(curString, n):  
    return curString + curString[-1] * n

# Miroir
def reflectString(curString):  
    return curString + curString[::-1]

# Insertion et remplacement
def appendCharacter(curString, char):  
    return curString + char

def prependCharacter(curString, char):  
    return char + curString

def insertCharacterAtPos(curString, p, char):  
    if p >= len(curString):
        return curString + char
    return curString[:p] + char + curString[p:]

def replaceCharacter(curString, target, replacement):  
    return curString.replace(target, replacement)

# Inverser une cha√Æne
def reverseString(curString):  
    return curString[::-1]
```

---

# **2. Cr√©ation du Rule Processing System**
On cr√©e **un dictionnaire** pour mapper les **codes de r√®gles** vers les fonctions associ√©es, ainsi qu‚Äôun **dictionnaire pour g√©rer le nombre d‚Äôarguments** requis par chaque fonction.

```python
# Mapping des r√®gles aux fonctions
ruleList = {
    "l": lowerString,
    "u": upperString,
    "c": capitalizeString,
    "i": invertCapitalize,
    "t": toggleString,
    "trL": truncateLeft,
    "trR": truncateRight,
    "d": duplicateString,
    "dN": duplicateStringNtimes,
    "df": duplicateFirst,
    "dl": duplicateLast,
    "r": reflectString,
    "a": appendCharacter,
    "p": prependCharacter,
    "ins": insertCharacterAtPos,
    "rep": replaceCharacter,
    "rev": reverseString
}

# Nombre d'arguments requis par chaque r√®gle
ruleCountList = {
    "l": 1, "u": 1, "c": 1, "i": 1, "t": 1, "trL": 1, "trR": 1, "d": 1,
    "dN": 2, "df": 2, "dl": 2, "r": 1, "a": 2, "p": 2, "ins": 3, "rep": 3, "rev": 1
}
```

---

# **3. Application dynamique des r√®gles sur une wordlist**
L‚Äôutilisateur pourra choisir une liste de **r√®gles √† appliquer** et le syst√®me appliquera les transformations correspondantes sur une **wordlist**.

```python
import os

def apply_rules_on_word(word, rules):
    """
    Applique une liste de r√®gles sur un mot donn√©.
    """
    modified_words = set()
    modified_words.add(word)  # Ajouter le mot original

    for rule in rules:
        if rule in ruleList:
            func = ruleList[rule]
            num_args = ruleCountList[rule]

            if num_args == 1:  # Fonction prenant un seul argument
                modified_words.add(func(word))
            elif num_args == 2:  # Fonction prenant deux arguments
                if rule == "a":  # Append
                    modified_words.add(func(word, "!"))
                elif rule == "p":  # Prepend
                    modified_words.add(func(word, "#"))
                elif rule == "df" or rule == "dl":  # Duplicate First/Last
                    modified_words.add(func(word, 2))
            elif num_args == 3:  # Fonction prenant trois arguments
                if rule == "ins":  # Insert
                    modified_words.add(func(word, 1, "_"))
                elif rule == "rep":  # Replace
                    modified_words.add(func(word, "a", "@"))

    return modified_words

def process_wordlist(input_file, output_file, rules):
    """
    Applique une s√©rie de r√®gles sur une wordlist.
    """
    if not os.path.exists(input_file):
        print(f"[ERROR] Fichier non trouv√© : {input_file}")
        return
    
    modified_words = set()

    with open(input_file, "r", encoding="utf-8") as infile:
        for line in infile:
            word = line.strip()
            modified_words.update(apply_rules_on_word(word, rules))

    with open(output_file, "w", encoding="utf-8") as outfile:
        for word in sorted(modified_words):
            outfile.write(word + "\n")

    print(f"[SUCCESS] Fichier g√©n√©r√© : {output_file}")

if __name__ == "__main__":
    input_file = input("Entrez le fichier contenant la wordlist : ").strip()
    rules = input("Entrez les r√®gles √† appliquer (ex: l,u,d): ").strip().split(",")
    output_file = "Output/modified_wordlist.txt"
    
    process_wordlist(input_file, output_file, rules)
```

---

# **4. Explication du code**
- **L‚Äôutilisateur choisit les r√®gles** qu‚Äôil veut appliquer.
- **Le script charge la wordlist et applique dynamiquement les transformations** sur chaque mot.
- **Les mots transform√©s sont enregistr√©s dans un fichier de sortie** (`Output/modified_wordlist.txt`).

---

# **5. R√©sum√©**
‚úÖ **Tu as maintenant un syst√®me complet de gestion des r√®gles**.  
‚úÖ **L‚Äôutilisateur peut activer les r√®gles de son choix dynamiquement**.  
‚úÖ **Le fichier g√©n√©r√© est pr√™t pour une attaque par dictionnaire**.  

---

# **6. Prochaine √©tape**
**Test ce fichier avec une wordlist existante.**  
Une fois valid√©, on passera √† **`passwordCracker.py`** pour utiliser cette wordlist dans **une vraie attaque** ! üöÄ  

---

üí° **Que penses-tu de cette impl√©mentation ?** üòä